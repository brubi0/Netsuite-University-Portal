Workflow Triggers Review-- understanding workflow triggers is critical to the development of properly designed workflows that optimize processing performance. This module provides a review of workflow triggers, which represent events that occur during the processing of records in NetSuite. We will review both client and server triggers, as well as the trigger event sequence, which specifies the order in which each trigger occurs during workflow processing.

In this module, we will discuss the following topics-- workflow triggers overview, understanding client triggers, understanding server triggers, and trigger event sequence. Upon the completion of this module, you will be able to define a workflow trigger and list some examples of how workflow triggers control action and transition execution, list each of the primary client and server triggers and explain when you might use each trigger, and list the sequence of events that occurred during the processing of a record and the workflow triggers associated with each.

Workflow triggers represent the events that occur during the processing of a record in NetSuite. They dictate when a workflow should perform certain tasks, such as when the workflow should be initiated, when actions should be executed, and when a record should transition from one state of the workflow to another.

The diagram shown here illustrates the fact that you can have workflow triggers that are used to initiate workflows. You can have action-based triggers, which are used to execute actions within states of the workflow. And you can configure triggers to execute transitions between the individual states of a workflow.

There are two types of workflow triggers, client triggers, which represent events that occur on the local computer within the user's web browser; and server triggers, which are events that occur on the NetSuite server. We'll begin our review of workflow triggers by examining client triggers.

As we mentioned earlier, climate triggers represent events that occur on the user's local computer in their website browser. However, one key distinction is that they only occur when creating a new record or editing an existing record. They do not occur when viewing a record.

There are two primary form-level client triggers, before user edit and before user submit. There are also three additional client triggers-- before field edit, after field edit, and after field sourcing-- which are used to create dynamic forms. Let's take a look at each one of these client triggers in more detail.

Before user edit occurs when a user creates a new record or edits an existing record. The browser loads a blank entry form when creating a new record. And when editing a record, the existing record in the database is loaded into the browser. Actions you might perform on the before-user-edit client trigger includes showing and hiding fields, making fields mandatory or optional, or defaulting values on the form.

The before-user-submit trigger occurs when the user makes changes to one or more the fields on a form and then saves the record. Before user submit is typically used to perform form-level validations on the client before being pushed to the server for additional processing.

In addition to the two form-level triggers we just discussed, there are three field-level quiet triggers that can be used to create dynamic forms that perform additional processing, such as field validations, updating fields, or changing field display characteristics based on the user's interactions with the form data itself. It's important to note that SuiteBuilder can also be used to manipulate the display of form data in NetSuite. However, these changes are very static in nature and require ongoing administration and may not meet the needs of all users in the system.

SuiteFlows client triggers, however, allow for the dynamic manipulation of form data based on the user's interactions with the data itself. Let's take a look at each of these three triggers in more detail. Before field edit is used to perform field level validations, after the user removes field focus or tabs out of a field, but before the client moves the data from the browser into memory, regardless of whether the field's value was changed or not-- during this event, the user is unable to interact with any other fields on the form until they enter a valid value.

After-field edit it is used to update the value of a field based on the value of another field. It occurs when exiting a field and performing a validation, and the field's value was actually changed, either through the selection of a value in a dropdown list or direct user entry.

After-field sourcing is similar to after-field edit, as they both execute upon changing the value of a field. However, after-field sourcing waits for any related sourcing to occur before continuing with additional processing. That way, it can take appropriate action on the sourced-in value. After-field sourcing is often used when performing on change processing when selecting a value from a list record field.

Here are some things to remember when working with client triggers. Client triggers only occur when creating new records or editing existing records. Use the before-user-edit trigger to default field values and change field display characteristics when loading records in the browser. Use before user submit to validate form fields during record save and return user-friendly error messages to the user. These messages are displayed as friendly pop-up windows rather than a whole SuiteScript error pages, which is common on actions configured on server triggers.

Separate actions configured on client triggers in separate single-state workflows, and use Control F5 on the Windows operating system and Command-R on Macintosh to refresh the browser page when testing client-side actions. Server triggers represent events that occur on the NetSuite server rather than in the user's web browser on the client. Unlike client triggers, which only occur when creating and editing and saving records, server triggers occur in all user-event contexts, even when viewing records.

It's also important to note that only server triggers can be used to initiate a workflow on a record. There are three server triggers-- before record load, before records submit, and after record submit. Let's take a look at each one in more detail. Before record load occurs just before record data is displayed on a client in the user's web browser as part of the HTTP response from NetSuite.

It allows for preprocessing on the record, such as setting default values in fields when a new record is being created or changing the display characteristics of fields on the form. Before record load is valid in the create, edit, and view contexts only.

Before records submit occurs just before the record is committed to the database. It is often used to perform form-level validations, calculations, field updates, and other business logic on the record being submitted or saved. Since no record data is committed to the database at this point in the process, it is possible to cancel the submission of the record and return an error to the user using a return user error action. As you might expect, before record submit is valid in the save context only.

After record submit occurs after the record has been successfully committed to the NetSuite database. All data saved with the submitted record is then available at after record submit. And it's an ideal trigger to use when creating new records using the create record action. Like before records submit, after record submit is valid in the save context only.

It's also worth noting that records are only committed to the database when all action's on the before-record-submit trigger have been executed without returning an error. This is because NetSuite does not have a database rollback feature. So a record is either fully committed to the database or not at all.

In addition to the three server triggers we just discussed, there are two additional state-based server triggers that are used to initiate workflows and execute actions and transitions when entering or exiting various states in a workflow. Unlike client and server triggers, however, these triggers are unique to each state of the workflow rather than to the form or record where client and server triggers manifest themselves. This relationship is illustrated here.

If you want actions to execute while the user is interacting with the form after it has been loaded into the user's browser, configure actions on client- or form-level triggers. If you want to affect the record itself, while it is either being loaded into the user's browser or after the record leaves the browser to begin processing on the server, which is typical of a record save event, configure actions on server- or record-level triggers. There are two state-based server triggers, entry and exit. Let's look at each one of these in more detail.

The entry trigger occurs the first time a record enters a state in a workflow and is often used when you want actions to execute once and only once when a record enters a state for the very first time. For example, here, you can see an action, Set Field Display Type configured on entry. When a record enters state one, load record, the Set Field Display Type action will be executed once and only once. Even if the record enters state one again at some other point in time, the action will not be re-executed.

However, if we look at an example such as the one you're seeing here, that same action is configured on before record load, the server trigger. This means that, every time the record enters state one, load record, the Set Field Display Type action is going to be executed. The exit trigger occurs the first time a record exits a state in a workflow. It is often used when you want an action to execute once and only once when a record exits a state for the first time.

Consider the example shown here. We have action one and action two. Action one is configured on entry, and action two is configured on exit. When a record enters state one for the very first time, action one is going to be executed once and only once. When the record transitions out of state one to state two, action two will be executed, but only once upon its initial exit from the state. This process continues in the remaining states of the workflow based on the configuration of actions in those states.

Here are some things to remember when working with server triggers. First, when configuring actions that affect field display characteristics, use before record load over the client trigger before user edit. Because the execution of client-side code can vary depending on the browser and browser version being used, configuring such actions on server triggers ensures consistent server-side processing of all code. If you want an action to execute only once when entering or exiting a state for the very first time, use entry or exit.

If a user refreshes their browser cache using Control-F5 or Command-R, any actions set to execute on entry will not be executed again as the record does not enter the state again; it is only reloaded. When saving a record, use the before-record-submit trigger when performing validations at the record level, and use the after-record-submit trigger when creating related records, sending emails, and navigating users to other pages in the user interface.

Earlier, we discussed how triggers occur and actions and transitions execute. To better understand workflow triggers and the order in which configured actions and transitions will be executed, it is helpful to understand the SuiteFlow trigger event sequence. First, let's review the fundamental process of working with any record in NetSuite.

A user creates a new record or opens an existing record for editing or viewing. The record form is loaded into the browser on the client. And the user edits the record. When the user is ready, the user then saves the record to the database. And finally, the record is actually saved or committed to the NetSuite server database. Each one of these events has a corresponding client or server trigger. Let's review where each of those occur in the processing of a record in NetSuite.

In step one, the user requests the display of a record, either through the creation of a new record or editing or viewing an existing record. The server retrieves the record from the database and passes it to the before-record-load-server trigger, which performs preprocessing on the record, such as setting default values in fields or changing field display characteristics.

In step two, page content is pushed to the browser in the HTTP response to the user's request for the record. The browser loads the page. And once the page is loaded, the before-user-edit-client trigger occurs. In step three, the user then makes changes to the fields on the form. Form-level client triggers, such as before field edit, after field edit, and after field sourcing occur based on the user's interaction with the various form fields.

in step four, the user then saves the record. The before-users-submit-client trigger occurs. And if any return user air actions are configured on that trigger, they will be executed. And if any validations fail, workflow processing stops. If there are no validation errors, processing continues on the server where the before-records-submit-server trigger occurs. Before record submit is an ideal place in which to perform validations in other server side business logic along with updating data on the record that is currently in the process of being saved.

In step five, the system then persists the record to the database, either inserting a new record or updating an existing record. There is no database rollback feature as we discussed earlier. The after-record-submit-server trigger occurs after the record has been successfully persisted to the database. All of the data from the submitted record is available at the after-record-submit-server trigger.

Another way to understand trigger event sequence is through action execution order. The diagram here illustrates this process based on a workflow being initiated at before record load when editing an existing record. This sets the active trigger to before record load upon entry into state one. In step one, actions and transitions on the entry trigger will execute first once and only once upon entry into the state.

In step two, actions configured on the same trigger in which the record entered the state-- in this case, before record load-- will be executed next. In step three, any actions configured on client triggers will then be executed, such as when the user is interacting with fields on a form. When the user saves the record, any actions configured on before user submit will then be executed.

In step five, processing shifts to the server, and the Save process continues where any action set to trigger on before records submit will be executed. Next, in step six, the workflow automatically transitions to a post-save context, at which time, any actions configured to trigger on after record submit will be executed. And finally, any actions configured on the exit trigger will be executed before the record transitions to the next stage of the workflow. This will happen once and only once upon the initial exit of state one.

It is now time for our next walk through demonstration. And in this demo, we're going to go ahead and introduce you to the performance review custom record type as well as the pre-built workflows that support a basic performance review process. And this is something that you're going to see, walkthrough, throughout this self-study course as the basis for the examples of my demonstration. So the first task that we'll go ahead and show you is we'll examine the performance review customer records. You can see the general structure of that customer record.

We'll then examine the pre-built performance review workflows that are in our training account. And then, we'll go ahead and create a performance review record and examine the execution of the individual actions and transitions in those workflows. Let's begin this demonstration by examining the performance review custom record that is pre-built in our training account.

To do that, I'm going to come up here to the Customization menu. I'm going to come down to Lists, Records, and Fields, and then come over to Record Types. And when I come in here, you'll see that we do have several that are locked by various bundles.

But the ones we care about are right down here. You'll see that we have some custom records called Furniture Request, which you'll be working with exclusively throughout this course. And I'll be demonstrating the performance review process using these custom record types, specifically, the performance review record here.

So the first thing I'm going to do is just go ahead and click on that record type just to view its definition. And I'm not going to spend a ton of time here, but I do want to point out the fields that comprise this particular form. You can see that we have a subordinate field, which actually is a join out to the employee record. Keep in mind that joins originate here at the record level in NetSuite on these custom records.

We have a review date of type date. We have a review type, which is actually a custom list record called performance review type where we can choose whether it's a salary-change review or a non-salary-change review. We have an overall rating code, which we'll be working with a little bit later where we can rate our subordinate who's going through the performance review process. Notice, that is a free-form text field.

We have a salary increase amount of type currency, supervisor comments, which is just a general text field, and then an approval status field which also has a custom list associated with it called performance review status. You can see those right there. So you can go and take a look at some of this as you're going through the course if you're interested to learn more about how this is constructed. But I just wanted to give you a quick flyby of the various fields that comprise this record.

And so if I come back to my list of custom records, and I simply click New Record next to performance review right here, you will see the fields that I just talked about. I'm just going to go and leave this form up here for a second. And we'll come back to it periodically as we discuss some of the workflows and actions that have been configured to process on this record. So let's take a look at our workflow.

And to get to our workflow, what I'm going to do is come up here to Customization, I'm going to come down to Workflow, and then to select Workflows. And I just want to bring up the list here. So I'm going to Right-click on that and Open that link in a new browser tab. OK, there we go. You can see that I do have my list of workflows here. These are actually the furniture request workflows that you will be working with as you work through your student exercises.

So I simply need to change my filter here from record type furniture request to performance review in order to see the workflows that I am particularly concerned with for the walk through demonstrations. And you can see that I do have five or so workflows here, one that we'll be looking at much later in the course. But you can see that I have an entry workflow, a load workflow, a save workflow, and an approval workflow.

And I think that's interesting to note, right off the bat here, is that we are building these workflows and will continue to build our workflows throughout this course in a modular fashion, meaning, we're dividing our workflows up into logical processing components that do very, very specific things. Not only are the actions logically grouped and executed in their respective workflows, but we're also doing it based on the types of triggers that those actions have been configured on.

So for example, if we just take a look at the very first workflow here in our list called the entry workflow-- I'm just going to go ahead and Select that in View Only mode, in Read Only mode. That'll be perfectly fine for what we're doing. And the first thing that you'll notice is that this entry workflow is a single-state workflow. And if I just look at the definition of it just for a second, you can see that it is configured on the performance review record type. And the initiation parameters are event-based and on the creation of a new record.

And the trigger type, if you recall, you can only initiate workflows on server triggers. And you can see that, because we're doing this on the create event, we're going ahead and setting the initiation trigger for this workflow to before record load. And that's really all we need to see there in terms of the overall initiation configuration.

But once this workflow starts processing records, you can see that it has several client-side configured actions associated with it. We have some actions configured on before user edit, a set field value action that sets the date equal to today, the review date.

We have a set field display label changing the display label of the name field to review period. We're changing whether a field is mandatory or not, whether the review type-- or sorry, whether the rating code is mandatory or optional depending on the value of the review type selection. And you can see these various actions configured here. If I just go back into our new record that we created just a few moments ago, and I simply do a refresh, Control-F5, since I'm on Windows here, it's going to reload that record in my browser.

Notice that the name field, which is actually what this is-- if I actually click on that, as you can clearly see, it is the name field. But the display label is actually being changed to review period. You can see the review date has been defaulted to today's date. And if I look over here, you can see that we do have some required fields based on the value of the review type.

So if I make the review type No Salary Change, notice that rating code is now optional. However, if I make the review type Salary Change, notice that rating code becomes mandatory, and the salary increase amount field is displayed. So this is how you can control and affect the display of form fields and display characteristics of form fields using client triggers and the actions provided by SuiteFlow.

So let me go ahead and flip back over to our workflow definition. And let's have a look at our load workflow and kind of see what it's doing. If I go ahead and just open that up to view its definition, you can see that this is also configured to initiate on the creation and on the view or update of new records as well as existing records. And it too is configured on the before-record-load trigger. And this is handling actions configured on record load.

So let's look at what we have here. Notice that everything is configured on the before-record-load trigger. So we have a set field value action that sets the review type equal to salary change by default. We have a set field display type on the subordinate field to make it inline. We have another set field display type to set the salary increase amount field to hidden when the review type is no salary change. I think I showed you that just a moment ago.

And you'll notice that we do, in fact, have the same actions configured that we looked at in the entry workflow where we had some actions configured on before user edit. And you can see that we do, in fact, have that same action set field display label, configured here on server trigger before record load as well. And that is there to ensure something called display persistence.

The basic premise is that you wouldn't want some actions executing on viewing records in a client context and not have those same actions expose themselves in a server context. So you need to make sure you duplicate them both on the client trigger before user edit as well as the server version of that trigger before record load in order to maintain that display consistency with those actions.

And then, finally, we do have that set field mandatory again on that rating code, which you saw. So very simple set of actions here-- but if I jump back to our record, once again, just do a quick Refresh, you can clearly see the default salary change action being taken care of there. And the other ones we already kind of looked at. We saw the fact that the subordinate's field is actually inline. I don't really know what that one was. Let's go back and have a look at that.

Subordinate inline-- there's no condition. Oh, on the edit event, that's right, that's filtered by the event type edit. So if you are editing a record, that's going to set the subordinate field to display as inline, and that's kind of a, again, a display persistence thing-- OK, so some various actions there.

Let's go back to our list of workflows and look at the save workflow real quick. Lots going on here. You can see that we have a multi-state workflow, first of all. And you can see that this actual workflow is configured to execute on the creation of new performance review records on the before-record-submit-server trigger-- so right when we click the save button and we send save processing to the NetSuite server.

And when this workflow initiates after our entry workflows, the first thing it's going to do is validate the rating code that was entered by the user. So it comes in to state 0 here and says, return a user error if the rating code is not A, B, or C. So we've got a condition that says, return an error to the user telling them that the rating code must be A, B, or C if they do not enter one of those values. As long as this validation passes, the process and workflow continues.

And the next thing it's going to do is, it's going to create a new task record as you can see here. It's going to send an email notification to the subordinate letting them know that they have a self-evaluation, performance review evaluation, to actually complete. And then, finally, it's going to execute a go-to record action, which is going to allow the user to enter a brand new performance review record immediately-- OK, very, very simple action there.

So let's take a look and see what this does. If I come back to our Record, I'm just going to go ahead and type in here M02 Test number 1. I'm going to keep my names very, very generic in case we need to come back and look at something. I'm going to go ahead and choose a subordinate of Aubrey Pober here. Actually, no, I'm going to choose Willheim Schueler, I'll choose him. I'll go ahead, and give him a rating code of B. And we'll give him a salary increase amount of $3,000. And I'll leave a little comment. I won't do this every time, but just so you can see the fields at play here, and I'm just going to go ahead and save that record.

Now, if I go to my list of performance review records, right here, you can see the new record. And if I open that up, I can certainly go out and look on my employee record to see if that notification email was sent. But I can just as easily come into my Workflow History on that record and see everything that went on from a workflow processing perspective. So we're concerned with the review performance review save workflow in this case. And if I click on the Log file, you can see that I do, in fact, have some actions that were executed.

I didn't have to return an error, because I entered an appropriate rating code. So it considered throwing that error, but it didn't need to. And it simply transferred to state 1 where it creates the task record. So let's see if it actually created the task record. You can see that we have a log entry indicating the ID of the new task record, 706, and it seems to have been executed successfully. And it then transitioned to state 2.

So let's have a look at state 2. There's the log. I have a send email action from the subordinate, or to the subordinate, which is 887-- that's their employee ID-- from the user, which, in my case, was Larry Nelson, who is employee minus 5. And then it transitions to state 3. I think you get the idea, but it looks like everything is processing beautifully on this particular record.

And then, finally, you'll see something here-- it actually initiated the approval workflow. And it's actually sitting here in state 1 waiting for approval. So let me jump back and show you that workflow real quick. Let me go back to my List of Workflows. I'm simply going to open up the approval workflow in View mode.

And once again, you'll see that it is, in fact, a multi-state workflow that has been set up and configured to execute on the creation of new performance review records in the after-record-submit context, so post-record save is when we're executing this particular record.

And the reason we're doing that is because we are setting some statuses that wouldn't be normally set until after the record is set. So that's a good example of when you would use after-record submit. So the idea here is, we come into state 1, and we have a set field value action that sets the value of the current approver equal to whoever the subordinate's supervisor is, so there is some approval going on here, obviously.

And then, we have basically some very simple actions, just literally adding some buttons so the approver can actually approve or reject that record. If, in fact, the record is approved, and there aren't any more approvers, it's going to be transitioned automatically to state 2 where we're setting the record status to approved and then locking the record. However, if the record is rejected, the performance review records is rejected, we're setting the value of the approval status field to rejected and locking the record.

So that is basically what this workflow is doing. And so if I come back over here to my Performance Review record, you can see that, because I just happened to be Larry Nelson here, I happen to be Willheim Scheuler's supervisor, notice that I do have an approve review button here.

And if I click Approve Review, notice that, down here in my workflow history, the workflow transitioned from state 1, waiting for approval-- and it showed me is the current approver-- to state 2, fully approved. OK, and if I look at the Log File for that, you can see the other actions here. I can see the fact that we set the value of the status field accordingly, so on, and so forth.

So this is really at the core of what you're going to see me walk through as we go through the walkthrough demonstrations throughout this course. It's going to be based on making changes and configuring these various workflows to do different things as we present each concept. It is now time for you to complete the required hands-on exercises associated with the topics discussed in this module. To complete the required exercises, refer to your student workbook. When you have finished, you may continue with the next module.

This concludes the Workflow Triggers Review module.