Understanding server triggers. In this module, we will continue our discussion of workflow triggers by focusing on server triggers, which represent events that occur on the NetSuite server during server-side workflow execution. We will also examine the workflow execution model, which defines the order in which all triggers occur during workflow processing. And we will discuss the importance of knowing what the active workflow trigger is at any state of a workflow and its effect on action and transition execution.

In this module, we will discuss the following topics-- server triggers and workflow trigger event sequence. Upon the completion of this module, you will be able to describe the primary difference between client-side and server-side triggers, list each of the server triggers and their role in the workflow execution cycle, and list the sequence of events triggers that occur during the processing of a record. Server triggers represent events that occur on the NetSuite server rather than in the user's web browser on their local computer. Unlike client triggers which only occur when creating, editing, and saving records, server triggers occur in all user event contexts, including when viewing existing records.

The three server triggers are before record load, before records submit, and after record submit. It's important to note that while both client and server triggers can be used to execute actions and transitions, only server triggers can be used to initiate workflow execution. Before record load occurs just before record data is displayed in the user's browser as part of the HTTP response to a record request. It allows for pre-processing of the form prior to display in the user's browser.

Before record load is valid in the create, edit, and view contexts only. Actions you might perform on the before record load server trigger includes setting default field values on forms, changing the display characteristics of fields on forms, and making fields mandatory or optional. Before record load is similar to the before user edit client trigger. However, it is advantageous to perform such actions when possible during before record load rather than using client triggers. This is because there was always a chance that client trigger behaviors can vary from browser to browser while server side processing using server triggers provides better processing consistency.

Before records submit occurs just before the record is committed to the server database. Since no record data has been committed to the database at this point in the records processing, it is possible to cancel the submission of the record and return an error to the user. The server commits the record to the database either inserting a new record or updating an existing record only when all configured actions on the before records submit trigger have been executed without returning an error.

Because NetSuite does not have a database rollback feature, a record is either fully committed to the database or it is not committed at all. Before record submit is valid in the same context only. Actions you might perform under before records submit server trigger include form-level validations, calculations, field updates, and other business logic on the record being submitted or saved.

After records submit occurs after the record has been successfully committed to the server database. All data saved with the submitted record is available at after record submit. Like before record submit, after records submit is valid in the save context only. After record submit is often used to create new Customer Relationship Management or CRM records such as customer and related task and phone call records.

In addition to the three primary server triggers, there are two additional state-level server triggers called entry and exit. Entry occurs the first time a record enters a state in a workflow. Use the entry trigger if you want actions to execute only once when a record enters a state for the first time. The exit trigger occurs the first time a record exits a state in a workflow. Use the exit trigger if you want an action to execute only once when a record exits the state for the first time.

Each of these triggers are considered state-level triggers unique to each state in a workflow rather than the form or record level where client and server triggers manifest themselves. If you want to have actions execute while the user is interacting with the form after it has been loaded into the user's browser, you will configure actions on client triggers, which are considered form-based triggers. If you want to affect the record itself while it is either being loaded into the user's browser or after the record leaves the browser to begin processing on the server, which is typical of a record save event, you will configure actions on server triggers which can be thought of as record-based triggers.

As we just discussed, entry occurs as soon as the record in the workflow transitions to a state. Use entry if you want actions to execute once as soon as the record enters the state. For example, if you have a set field display type action configured on the entry server trigger, it will be executed only once the first time the record enters the state. However, actions and transitions that execute on the entry trigger depend on the server trigger on which the record entered the state.

In this example that same set field display type action will execute every time the record enters the state if configured on the before record load server trigger. If users refresh their browser cache while a record is in a specific state, any actions configured to execute on the entry trigger will not be executed again. This is because refreshing the browser simply reloads the record in the current state. It does not force the record to re-enter the state again.

Taking this one step further, let's assume you have a state that contains a send email action configured on the entry trigger yet the record enters the state on the before record load trigger as shown here. The send email action will not execute because the before record load trigger is not a valid trigger type for the send email action. Finally, the exit server trigger occurs the first time a record exits a state in a workflow. Use the exit trigger if you want an action to execute only once when a record exits a state for the very first time.

It's important to note, the entry and exit triggers apply to all actions and transitions except the confirm and show message actions, which are only supported on client triggers. Earlier we discussed how triggers occur and workflows, actions, and transitions execute. To better understand workflow triggers and the order in which configured actions and transitions will be executed, it is helpful to understand the SuiteFlow trigger event sequence.

First, let's briefly talk about the fundamental process of working with any record in NetSuite. The process begins with the user creating a new record or opening an existing record for viewing or editing. The record form is loaded into the user's browser on the client.

The user edits the record, then the user saves the record. When the user saves the record the record is committed to the database. Each of these events occur based on an associated client or server trigger.

Consider the following workflow trigger event sequence diagram. In step 1, the user requests the display of a record either through the creation of a new record or by viewing or editing an existing record. The server retrieves the record from the database and passes it to the before record load server trigger, which performs pre-processing on the record form, such as setting default values in fields or changing the display characteristics of fields on the form.

In step 2, page content is pushed to the browser in the HTTP response to the record request. The browser loads the page. Once the page is loaded, the before a user edit client trigger occurs. In step 3, the user makes changes to fields on the form. Form level client triggers such as before field edit, after field edit, and after field sourcing occur based on the user's interaction with the form fields.

In step 4, the user saves the record. The before user submit client trigger occurs. If a return user error action is executed, workflow processing stops at this point.

If there are no validation errors, processing continues on the server or the before record submit server trigger occurs. Before records submit is an ideal place in which to perform validations and other business logic, such as calculations along with updating data on the record that is currently in the process of being saved. There has been no data persistence at this point, so it is possible to cancel the submittal of the record and return an error to the end user by executing the return user error action.

In step 5, the system persists the record in the database, either inserting a new record or updating an existing record. This only occurs when before records submit executes without returning an error. There is no database rollback feature once the record is persisted.

The changes are always in the database once the persistence takes place. Finally, the after records submit server trigger occurs after the record has been successfully persisted in the database. All of the data from the submitted record will be available at after record submit.

Now let's examine the trigger event sequence and its effect on the order of action execution for a workflow executing during the edit of an existing record. The record is retrieved from the database at before record load as you can see here. So the active trigger entering state 1 is before record load.

In step 1, actions and transitions on the entry trigger will execute first and only once when the record enters the state. If a record transitions back to state 1, the actions configured on entry do not execute again. In step 2, actions configured on the same trigger in which the record entered the state will be executed. In this example, that is before record load.

In step 3, any actions configured on client triggers will then be executed next. This occurs as the user is interacting with the form. When the user saves the record, any actions configured on before user submit are executed.

In step four, the save process continues on the server where any action set to trigger on before record submit will be executed. In step 5 the workflow will automatically transition to a post save context, at which time any action is set to execute on after record submit will be processed. In step 6, any actions on the exit trigger will execute before the record transitions to the next state in the workflow. These actions execute once when the record transitions to another state. If a record transitions back into the state and then re-exits that state, the actions will not be executed again.

Here are some key things to remember when working with server triggers. Use before record load rather than before user edit when configuring actions that affect the display characteristics of form fields when loading a record. If you want an action to execute only once when entering or exiting a state, use the entry or exit server trigger.

If a user refreshes their browser cache, any actions set to execute on entry or exit will not execute again. The record does not enter the state again. The record form is only reloaded in the browser.

The entry trigger differs from the before record load trigger in that actions set to execute on entry do not need to be loaded into the browser. When a record is saved, use the before record submit trigger when setting record data and performing validations. Use the after record submit trigger when creating related records, sending emails, and navigating users to other pages or records in NetSuite. This concludes the understanding server triggers module.